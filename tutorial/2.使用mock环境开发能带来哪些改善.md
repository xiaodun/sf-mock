# 前端与后端的关系

接口文档是前端与后端的纽带。

前端在意的是接口签名，即传参和返回格式，实现功能无需依赖真实接口的调用，双方按照文档各自开发。

例如我调用了发布接口，传参是正确的，接口在实现功能上有问题，尽管表现在前端，但这个责任应该由对应后端来负责。

# mock 环境的实现方案

第一步 : 用 node 写一个 mock 服务器部署在自己电脑上，电脑能编写代码那么就能正常启动，主要是解析请求，并返回指定的数据格式，非常的有安全感。

比如涉及角色问题，就直接给你返回一个超级管理员的数据，也不用在意用户名和密码，我们就只是改一些 UI，需要真正的登录吗？ 不需要，十分的便捷。

第二步 : 在项目上直接连 node 服务器会有跨域问题，尽管可以在 mock 服务器里统一解决，但是会产生一个 options 请求，通过 webpack 处理，会涉及到重新启动，很麻烦。

所以采用 nginx 做代理转发，普通请求走项目地址，api 请求走 mock 服务器，实现对代码的零入侵。

第三步 : 服务器是一个独立的项目，避免了重复的配置，也减少了集成和部署上的问题。

# 前端在迭代中的职责

mock 服务器是无法替代真正的接口调用，比如删除列表中的一条数据，在真实的接口调用中，可能涉及多个接口的改动，如果想要在 mock 服务器实现这些逻辑，无疑会增大成本，我们也不会期望数据真的被删除，毕竟这条数据包含着其它测试逻辑，两者之间确实很矛盾。

虽然前面吐槽联调是前端在测试接口，使用 mock 环境后数据多是静态的，这需要自测方案上做出调整，在一些场景下也会显得蹩脚，但这可以提升我们对代码的理解，是利大于弊的。

而 mock 环境能发挥多大的效应，也体现在团队规范的落地，比如后端对接口格式改动频繁，或者同一个功能不同后端实现的不一样、解决方案不明确，那么不调用真实接口与预期的行为会相差很多，提测质量难以保证就不好了，因为使用 mock 环境是不会报错的。

针对上面的问题，要坚信一点，谁的问题谁来承担，对于第一次接触一个项目，第一次和一个后端人员合作，联调熟悉彼此，遇到问题积极反馈，不要总是默默忍受不合理的东西。然后逐渐减少在联调上面花费的时间，你就会发现，当大家都规范化，做起事情来是有多得心应手。

而这个时候前端需要做的，就是把界面提供出来方便后端测试自己写的代码。

项目地址: https://github.com/xiaodun/sf-mock
